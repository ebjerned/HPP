#include <stdio.h>
#include <stdlib.h>


typedef struct temprange {
	struct temprange* next_node;
	int index;
	float min, max;
} temprange_node;

int add_to_database(int index, float min, float max, temprange_node** root);
int remove_from_database(int index, temprange_node** root);
int remove_database(temprange_node** root);
void print_database(temprange_node* db);



int main(){
	char comm;
	int index;
	float min, max;
	int running = 1;
	temprange_node* root = NULL;


	while(running){
		printf("Enter command: ");
		scanf(" %c",&comm);
		switch(comm){
			case 'A':
				scanf(" %i %f %f", &index, &min, &max); 
				add_to_database(index, min, max, &root);
				break;
			case 'D':
				scanf(" %i", &index);
				printf("Deleted: %i \n", index);
				break;
			case 'P':
				print_database(root);
				break;
			case 'Q':
				running = 0;
				break;
			default:
				printf("Command not defined");
		}
	}
	remove_database(&root);
	return 0;

}

int add_to_database(int index, float min, float max, temprange_node** root){
	if (index > 31 || index < 1) return 0;
	temprange_node* new_entry = (temprange_node*)malloc(sizeof(temprange_node));

	new_entry->index = index;
	new_entry->min = min;
	new_entry->max = max;
	new_entry->next_node = NULL;

	// If database is empty -> Assign root node
	if(*root == NULL){
		*root = new_entry;
		return 1;
	}
	temprange_node* curr = *root;/*
	// If there is atleast one node in the database
	while(curr != NULL){

		// When comparing the entered node to the current and next node
		temprange_node* next = curr->next_node;
		if(next != NULL){
			// If the entered node is between two indicies
			if(next->index > index && curr->index < index){
				new_entry->next_node = curr->next_node;
				curr->next_node = new_entry;
				return 1;
			}
			// If the entered node already exists as the next node -> Replace the c
			if(next->index == index){
				new_entry->next_node = next->next_node;
				curr->next_node = new_entry;
				free(next);
				return 1;
			}
			curr = next;
		} else {
			// If the entered node is smaller than the first node -> Reassign root node
			if (curr->index > index){
				new_entry->next_node = *root;
				*root = new_entry;
				return 1;
			}
			if (curr->index == index){
				new_entry->next_node = curr->next_node;
				

			}
			// If the next node does not exists, and the entered is not smaller than the current node ->
			// Enterred nod is the last node of the database
			curr->next_node = new_entry;
			return 1;
		}
	}*/
	temprange_node* next = curr->next_node;
/*	//Less than root
	if((*root)->index > index){
		printf("Less that root");
		new_entry->next_node = *root;
		*root = new_entry;
		return 1;
	}
	temprange_node* prev = NULL;
	while(next != NULL && next->index < index){
		//is equal to curr
		if(curr->index == index){
			printf("Is equal, no edge case");
			new_entry->next_node = next;
			if(prev != NULL) prev->next_node = new_entry;
			free(curr);
			return 1;
		}
		if(curr->index < index &&  index < next->index){
			printf("Is larger than current, but less than next");
			new_entry->next_node = next;
			curr->next_node = new_entry;
			return 1;
		}
		prev = curr;
		curr = next;
		next = next->next_node;
		//is larger than curr 
		//re assign prev, curr, next
	}

	if(curr->index == index){
		printf("Equal to right edge");
		if(prev != NULL) prev->next_node = new_entry;
		free(curr);
		return 1;
	}
	if(curr->index < index){
		printf("Larger than edge");
		printf("Edge index: %i", curr->index);
		curr->next_node = new_entry;
		return 1;
	}
	//is equal to curr, no next
	//is bigger than curr, no next

*/


	if(curr == NULL || curr->index >= index){
		new_entry->next_node = curr;
		curr = new_entry;
		return 1;
	}
	while(curr->next_node != NULL && curr->next_node->index < index){
		curr = curr->next_node;
		printf("Edege index %i\n", curr->index);
	}
	if(curr->next_node == NULL){
		curr->next_node = new_entry;
	}else if (curr->next_node->index > index){
		new_entry->next_node = curr->next_node;
		curr->next_node = new_entry;
	}else if (curr->next_node->index == index){
		new_entry->next_node = curr->next_node->next_node;
		curr->next_nodet = new_entry;
	}
	
	return 0;
}

void print_database(temprange_node* root){ 
	printf("%p\n", root);
	if(root == NULL){
		printf("Database is empty\n");
		return;
	}
	printf("day\tmin\tmax\n");

	temprange_node* curr = root;
	while(1){
		printf("%i\t%f%f\n", curr->index, curr->min, curr->max);
		if (curr->next_node == NULL) break;
		curr = (temprange_node*)(curr->next_node);
	}
	return;
}

int remove_database(temprange_node** root){
	temprange_node* curr = *root;
	while(curr != NULL){
		
		if(curr->next_node == NULL){
			free(curr);
			return 1;
		}
		temprange_node* next = (temprange_node*)(curr->next_node);
		free(curr);
		curr = next;

	}
	return 1;
}
